% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mesh_raster.R
\name{mesh_raster}
\alias{mesh_raster}
\alias{mesh_raster.mesh3d}
\alias{mesh_raster.matrix}
\alias{mesh_raster.data.frame}
\title{Mesh raster}
\usage{
mesh_raster(x, grid = NULL, n = 128)

\method{mesh_raster}{mesh3d}(x, grid = NULL, n = 128)

\method{mesh_raster}{matrix}(x, grid = NULL, n = 128)

\method{mesh_raster}{data.frame}(x, grid = NULL, n = 128)
}
\arguments{
\item{x}{matrix of points, or a mesh3d}

\item{grid}{raster to populate}

\item{n}{grid size of raster if 'grid' not supplied}
}
\value{
Raster
}
\description{
Create a raster by interpolating across triangles
}
\details{
At the moment, mesh_raster is identical to \link{tri_fun}
for the matrix x-y-z case, but adds capability for
a mesh3d object (of triangles).
Barycentric interpolation is used to efficiently obtain
a within-triangle estimate of a field of values
}
\examples{
data("humface", package = "Rvcg")
x <- humface
grid <- mesh_raster(x, n = 256)
raster::plot(grid, col = grey.colors(21), 
    breaks = quantile(grid, seq(0, 1, length = 22), na.rm = TRUE))
anglr::plot3d(grid)

## interpolate from raw points
xyz <- quakes[c("long", "lat", "depth")]
xyz$depth <- -xyz$depth
gx <- mesh_raster(xyz)
rat <- 1/cos(mean(xyz[["lat"]]) * pi/180)
raster::image(gx, asp = rat, 
  col = hcl.colors(12, "YlOrRd"))
maps::map(add = TRUE)
points(xyz, pch = "+", cex = 0.3)
## add some dummy points (we aren't modelling the world)

xex <- cbind(expand.grid(long = range(xyz$long), 
                         lat = range(xyz$lat)), depth = 0)
g2 <- mesh_raster(rbind(xex, xyz))
raster::image(g2, asp = rat)
maps::map(add = TRUE)
points(xyz, pch = "+", cex = 0.3)
anglr::plot3d(g2); rgl::aspect3d(1, rat, 0.1)
rgl::points3d(xyz$long, xyz$lat, xyz$depth + 30)
}
